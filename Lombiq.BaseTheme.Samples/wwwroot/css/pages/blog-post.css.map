{"version":3,"sources":["../../../Lombiq.BaseTheme/node_modules/bootstrap/scss/mixins/_breakpoints.scss","pages/blog-post.scss","../../../Lombiq.BaseTheme/Assets/Styles/abstracts/_mixins.scss","pages/blog-post.css","abstracts/_mixins.scss"],"names":[],"mappings":"AA4EI;ECjEA;IC4MqC,2CAAA;ECpNvC;AACF;AH8GI;ECvGA;IC8MqC,yCAAA;ECjNvC;AACF;AHyGI;ECvGA;ICgNqC,0CAAA;EC9MvC;AACF;AHoGI;ECvGA;ICkNqC,yCAAA;EC3MvC;AACF;AH4CI;ECpDA;ICoNmC,2CAAA;ECxMrC;AACF;AFTI;EACI,aAAA;EACA,mBAAA;AEWR;AFRI;EACI,kBAAA;AEUR;AFNQ;EACI,YAAA;EACA,iBAAA;AEQZ;AFLQ;EACI,aAAA;AEOZ;AHsCI;ECzCA;ICoLqC,8CAAA;EC7KvC;AACF;AHuEI;EC/EA;ICsLqC,4CAAA;EC1KvC;AACF;AHkEI;EC/EA;ICwLqC,6CAAA;ECvKvC;AACF;AH6DI;EC/EA;IC0LqC,4CAAA;ECpKvC;AACF;AHKI;EC5BA;IC4LmC,8CAAA;ECjKrC;AACF;ACrCI;EACI,4BAAA;EACA,WAAA;EACA,iBAAA;ADuCR;ACpCI;EAAQ,aAAA;ADuCZ","file":"blog-post.css","sourcesContent":["// Breakpoint viewport sizes and media queries.\n//\n// Breakpoints are defined as a map of (name: minimum width), order from small to large:\n//\n//    (xs: 0, sm: 576px, md: 768px, lg: 992px, xl: 1200px)\n//\n// The map defined in the `$grid-breakpoints` global variable is used as the `$breakpoints` argument by default.\n\n// Name of the next breakpoint, or null for the last breakpoint.\n//\n//    >> breakpoint-next(sm)\n//    md\n//    >> breakpoint-next(sm, (xs: 0, sm: 576px, md: 768px, lg: 992px, xl: 1200px))\n//    md\n//    >> breakpoint-next(sm, $breakpoint-names: (xs sm md lg xl))\n//    md\n@function breakpoint-next($name, $breakpoints: $grid-breakpoints, $breakpoint-names: map-keys($breakpoints)) {\n  $n: index($breakpoint-names, $name);\n  @if not $n {\n    @error \"breakpoint `#{$name}` not found in `#{$breakpoints}`\";\n  }\n  @return if($n < length($breakpoint-names), nth($breakpoint-names, $n + 1), null);\n}\n\n// Minimum breakpoint width. Null for the smallest (first) breakpoint.\n//\n//    >> breakpoint-min(sm, (xs: 0, sm: 576px, md: 768px, lg: 992px, xl: 1200px))\n//    576px\n@function breakpoint-min($name, $breakpoints: $grid-breakpoints) {\n  $min: map-get($breakpoints, $name);\n  @return if($min != 0, $min, null);\n}\n\n// Maximum breakpoint width.\n// The maximum value is reduced by 0.02px to work around the limitations of\n// `min-` and `max-` prefixes and viewports with fractional widths.\n// See https://www.w3.org/TR/mediaqueries-4/#mq-min-max\n// Uses 0.02px rather than 0.01px to work around a current rounding bug in Safari.\n// See https://bugs.webkit.org/show_bug.cgi?id=178261\n//\n//    >> breakpoint-max(md, (xs: 0, sm: 576px, md: 768px, lg: 992px, xl: 1200px))\n//    767.98px\n@function breakpoint-max($name, $breakpoints: $grid-breakpoints) {\n  $max: map-get($breakpoints, $name);\n  @return if($max and $max > 0, $max - .02, null);\n}\n\n// Returns a blank string if smallest breakpoint, otherwise returns the name with a dash in front.\n// Useful for making responsive utilities.\n//\n//    >> breakpoint-infix(xs, (xs: 0, sm: 576px, md: 768px, lg: 992px, xl: 1200px))\n//    \"\"  (Returns a blank string)\n//    >> breakpoint-infix(sm, (xs: 0, sm: 576px, md: 768px, lg: 992px, xl: 1200px))\n//    \"-sm\"\n@function breakpoint-infix($name, $breakpoints: $grid-breakpoints) {\n  @return if(breakpoint-min($name, $breakpoints) == null, \"\", \"-#{$name}\");\n}\n\n// Media of at least the minimum breakpoint width. No query for the smallest breakpoint.\n// Makes the @content apply to the given breakpoint and wider.\n@mixin media-breakpoint-up($name, $breakpoints: $grid-breakpoints) {\n  $min: breakpoint-min($name, $breakpoints);\n  @if $min {\n    @media (min-width: $min) {\n      @content;\n    }\n  } @else {\n    @content;\n  }\n}\n\n// Media of at most the maximum breakpoint width. No query for the largest breakpoint.\n// Makes the @content apply to the given breakpoint and narrower.\n@mixin media-breakpoint-down($name, $breakpoints: $grid-breakpoints) {\n  $max: breakpoint-max($name, $breakpoints);\n  @if $max {\n    @media (max-width: $max) {\n      @content;\n    }\n  } @else {\n    @content;\n  }\n}\n\n// Media that spans multiple breakpoint widths.\n// Makes the @content apply between the min and max breakpoints\n@mixin media-breakpoint-between($lower, $upper, $breakpoints: $grid-breakpoints) {\n  $min: breakpoint-min($lower, $breakpoints);\n  $max: breakpoint-max($upper, $breakpoints);\n\n  @if $min != null and $max != null {\n    @media (min-width: $min) and (max-width: $max) {\n      @content;\n    }\n  } @else if $max == null {\n    @include media-breakpoint-up($lower, $breakpoints) {\n      @content;\n    }\n  } @else if $min == null {\n    @include media-breakpoint-down($upper, $breakpoints) {\n      @content;\n    }\n  }\n}\n\n// Media between the breakpoint's minimum and maximum widths.\n// No minimum for the smallest breakpoint, and no maximum for the largest one.\n// Makes the @content apply only to the given breakpoint, not viewports any wider or narrower.\n@mixin media-breakpoint-only($name, $breakpoints: $grid-breakpoints) {\n  $min:  breakpoint-min($name, $breakpoints);\n  $next: breakpoint-next($name, $breakpoints);\n  $max:  breakpoint-max($next);\n\n  @if $min != null and $max != null {\n    @media (min-width: $min) and (max-width: $max) {\n      @content;\n    }\n  } @else if $max == null {\n    @include media-breakpoint-up($name, $breakpoints) {\n      @content;\n    }\n  } @else if $min == null {\n    @include media-breakpoint-down($next, $breakpoints) {\n      @content;\n    }\n  }\n}\n","// ---------------------------------------------------------------------------------------------------------------------\n// Blog Post page rules\n// ====================\n// This stylesheet is only injected as a resource when the server is displaying a BlogPost content type (see:\n// Services/ResourceFilters.cs).\n// ---------------------------------------------------------------------------------------------------------------------\n\n@import \"../abstracts/mixins\";\n\n// Here we are styling built-in fields and parts.\n.blog-post {\n    & > p:first-child {\n        @include margin-top-gutter;\n    }\n\n    .field-type-taxonomyfield {\n        display: flex;\n        flex-direction: row;\n    }\n\n    .taxonomy-tag-term, .taxonomy-term {\n        font-style: italic;\n    }\n\n    .field-type-taxonomyfield .taxonomy-tag-term {\n        &::before {\n            content: \"|\";\n            padding: 0 0.5rem;\n        }\n\n        &:first-child::before {\n            display: none;\n        }\n    }\n\n    .field-name-blog-post-image {\n        @include media-field-banner;\n    }\n}\n\n// END OF TRAINING SECTION: Sass styling and structure\n\n// NEXT STATION: Services/AccountNavigationProvider.cs\n","// --------------------------------------------------------------------------------------------------------------------\n// Application-wide Sass mixins\n// --------------------------------------------------------------------------------------------------------------------\n\n@use \"sass:map\";\n@import \"../vendors/bootstrap-mixins\";\n\n@function image($path, $base: $images-path) {\n    @return url($base + $path);\n}\n\n/// Event wrapper\n/// @author Harry Roberts\n/// @param {Bool} $self [false] - Whether or not to include current selector\n/// @link https://twitter.com/csswizardry/status/478938530342006784 Original tweet from Harry Roberts\n@mixin on-event($self: false) {\n    @if $self {\n        &,\n        &:hover,\n        &:active,\n        &:focus {\n            @content;\n        }\n    } @else {\n        &:hover,\n        &:active,\n        &:focus {\n            @content;\n        }\n    }\n}\n\n/// Make a context based selector a little more friendly\n/// @author Hugo Giraudel\n/// @param {String} $context\n@mixin when-inside($context) {\n    #{$context} & {\n        @content;\n    }\n}\n\n/// Applies breakpoint-specific values to a given property.\n/// @param {String} $property - The property to apply the values to.\n/// @param {Map} $breakpoint-values - The dictionary where the breakpoints are keys and the values are the values to be\n///                                   applied.\n/// @param {Bool} $down - Set to true if the values should be applied below the given breakpoint instead of above it.\n@mixin breakpoint-property-value($property, $breakpoint-values, $down: false) {\n    @each $breakpoint, $value in $breakpoint-values {\n        @if $down {\n            @include media-breakpoint-down($breakpoint) {\n                #{$property}: $value;\n            }\n        } @else {\n            @include media-breakpoint-up($breakpoint) {\n                #{$property}: $value;\n            }\n        }\n    }\n}\n\n/// Applies values to a given property (should be 'padding' or 'margin') based on a breakpoint-value dictionary\n/// that is either horizontal or vertical (or both) with an additional option to apply negative values.\n/// @param {String} $property - The property to apply the values to, 'padding' or 'margin'.\n/// @param {Map} $breakpoint-values - The dictionary where the breakpoints are keys and the values will be applied.\n/// @param {Bool} $horizontal [true] - Defines whether horizontal values should be applied or not.\n/// @param {Bool} $vertical [false] - Defines whether vertical values should be applied or not.\n/// @param {Bool} $negative [false] - Defines whether the values should be applied will be negated or not\n///                                   based on the assumption that the dictionary holds positive values only.\n/// @require $property, $breakpoint-values\n@mixin breakpoint-side-property($property, $breakpoint-values, $horizontal: true, $vertical: false, $negative: false) {\n    @each $breakpoint, $values in $breakpoint-values {\n        $value: if($negative, -$values, $values);\n\n        @include media-breakpoint-up($breakpoint) {\n            @if $horizontal == true {\n                #{$property}: {\n                    left: $value;\n                    right: $value;\n                }\n            }\n\n            @if $vertical == true {\n                #{$property}: {\n                    top: $value;\n                    bottom: $value;\n                }\n            }\n        }\n    }\n}\n\n/// Creates a horizontal or vertical (or both) margin based on a breakpoint-value dictionary\n/// with an additional option to apply negative values.\n/// @param {Map} $breakpoint-values - The dictionary where the breakpoints are keys and the values will be applied.\n/// @param {Bool} $horizontal [true] - Defines whether horizontal values should be applied or not.\n/// @param {Bool} $vertical [false] - Defines whether vertical values should be applied or not.\n/// @param {Bool} $negative [false] - Defines whether the values should be applied will be negated or not\n///                                   based on the assumption that the dictionary holds positive values only.\n/// @require $breakpoint-values\n@mixin breakpoint-margin($breakpoint-values, $horizontal: true, $vertical: false, $negative: false) {\n    @include breakpoint-side-property(\n        $property: \"margin\",\n        $breakpoint-values: $breakpoint-values,\n        $horizontal: $horizontal,\n        $vertical: $vertical,\n        $negative: $negative);\n}\n\n/// Creates a horizontal or vertical (or both) padding based on a breakpoint-value dictionary\n/// with an additional option to apply negative values.\n/// @param {Map} $breakpoint-values - The dictionary where the breakpoints are keys and the values will be applied.\n/// @param {Bool} $horizontal [true] - Defines whether horizontal values should be applied or not.\n/// @param {Bool} $vertical [false] - Defines whether vertical values should be applied or not.\n/// @param {Bool} $negative [false] - Defines whether the values should be applied will be negated or not\n///                                   based on the assumption that the dictionary holds positive values only.\n/// @require $breakpoint-values\n@mixin breakpoint-padding($breakpoint-values, $horizontal: true, $vertical: false, $negative: false) {\n    @include breakpoint-side-property(\n        $property: \"padding\",\n        $breakpoint-values: $breakpoint-values,\n        $horizontal: $horizontal,\n        $vertical: $vertical,\n        $negative: $negative);\n}\n\n@mixin text-size($text-size-level: 1) {\n    @if $text-size-level < 5 {\n        font-size: map.get($font-sizes, $text-size-level + 1);\n\n        @include media-breakpoint-up(md) {\n            font-size: map.get($font-sizes, $text-size-level);\n        }\n    } @else {\n        font-size: map.get($font-sizes, $text-size-level);\n    }\n}\n\n/// The following class names will be generated for each breakpoint (one value from each row, concatenated by hyphen,\n/// prefixed by \"u-\"):\n/// pd mg\n/// top bottom left right hor ver all\n/// xs sm md lg xl\n///\n/// Examples: u-pd-hor-md, u-pd-all-xs, u-mg-top-xl, u-mg-ver-sm, etc.\n/// @param {Map} $spacing-sizes - The dictionary where the breakpoints are keys and the values are spacing maps like\n///                               \"(xs: 24px, sm: 36px, md: 48px, lg: 96px)\".\n/// @param {Map} $spacing-directions - The dictionary where the breakpoints are keys and the values are padding/margin\n///                                    directions.\n@mixin generate-spacing(\n    $spacing-sizes: (xs: $spacing-xs, sm: $spacing-sm, md: $spacing-md, lg: $spacing-lg, xl: $spacing-xl),\n    $spacing-directions: (top: top, bottom: bottom, left: left, right: right, hor: left right, ver: top bottom, all: top bottom left right)) {\n    // Mapping size maps to size names, analogous to Bootstrap size names.\n    @each $spacing-size, $spacing-values in $spacing-sizes {\n        @each $breakpoint, $size in $spacing-values { // Mapping spacing values to breakpoints.\n            @include media-breakpoint-up($breakpoint) { // Applying breakpoint.\n                // Mapping directions to sides, e.g. top = top, hor(izontal) = left + right. #spell-check-ignore-line\n                @each $spacing-direction, $spacing-sides in $spacing-directions {\n                    .u-pd-#{$spacing-direction}-#{$spacing-size} { // Padding utility class name with direction & size.\n                        @each $spacing-side in $spacing-sides { // Iterating through each side in the direction map.\n                            padding-#{$spacing-side}: $size; // Applying spacing value to the current side.\n                            word-break: break-word;\n                        }\n                    }\n\n                    .u-mg-#{$spacing-direction}-#{$spacing-size} { // Margin utility class name with direction and size.\n                        @each $spacing-side in $spacing-sides {\n                            margin-#{$spacing-side}: $size;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n@mixin hide-text {\n    line-height: 0;\n    font-size: 0;\n    color: transparent;\n}\n\n/// Apply it to <ul> elements to eliminate the padding and list style.\n@mixin reset-list {\n    padding: 0;\n\n    & > li {\n        list-style: none;\n    }\n}\n\n@mixin padding-gutter($vertical-multiplier: $default-vertical-multiplier) {\n    @include media-breakpoint-only(xs) { padding: calc(var(--gutter-x-small) * #{$vertical-multiplier}) var(--gutter-x-small); }\n\n    @include media-breakpoint-only(sm) { padding: calc(var(--gutter-small) * #{$vertical-multiplier}) var(--gutter-small); }\n\n    @include media-breakpoint-only(md) { padding: calc(var(--gutter-medium) * #{$vertical-multiplier}) var(--gutter-medium); }\n\n    @include media-breakpoint-only(lg) { padding: calc(var(--gutter-large) * #{$vertical-multiplier}) var(--gutter-large); }\n\n    @include media-breakpoint-up(xl) { padding: calc(var(--gutter-x-large) * #{$vertical-multiplier}) var(--gutter-x-large); }\n}\n\n@mixin margin-gutter($vertical-multiplier: $default-vertical-multiplier) {\n    @include media-breakpoint-only(xs) { margin: calc(var(--gutter-x-small) * #{$vertical-multiplier}) var(--gutter-x-small); }\n\n    @include media-breakpoint-only(sm) { margin: calc(var(--gutter-small) * #{$vertical-multiplier}) var(--gutter-small); }\n\n    @include media-breakpoint-only(md) { margin: calc(var(--gutter-medium) * #{$vertical-multiplier}) var(--gutter-medium); }\n\n    @include media-breakpoint-only(lg) { margin: calc(var(--gutter-large) * #{$vertical-multiplier}) var(--gutter-large); }\n\n    @include media-breakpoint-up(xl) { margin: calc(var(--gutter-x-large) * #{$vertical-multiplier}) var(--gutter-x-large); }\n}\n\n@mixin apply-gutter($property, $multiplier: 1) {\n    @include media-breakpoint-only(xs) { #{$property}: calc(#{$multiplier} * var(--gutter-x-small)); }\n\n    @include media-breakpoint-only(sm) { #{$property}: calc(#{$multiplier} * var(--gutter-small)); }\n\n    @include media-breakpoint-only(md) { #{$property}: calc(#{$multiplier} * var(--gutter-medium)); }\n\n    @include media-breakpoint-only(lg) { #{$property}: calc(#{$multiplier} * var(--gutter-large)); }\n\n    @include media-breakpoint-up(xl) { #{$property}: calc(#{$multiplier} * var(--gutter-x-large)); }\n}\n\n@mixin padding-top-gutter($multiplier: 1) {\n    @include apply-gutter(\"padding-top\", $multiplier);\n}\n\n@mixin padding-right-gutter($multiplier: 1) {\n    @include apply-gutter(\"padding-right\", $multiplier);\n}\n\n@mixin padding-bottom-gutter($multiplier: 1) {\n    @include apply-gutter(\"padding-bottom\", $multiplier);\n}\n\n@mixin padding-left-gutter($multiplier: 1) {\n    @include apply-gutter(\"padding-left\", $multiplier);\n}\n\n@mixin margin-top-gutter($multiplier: 1) {\n    @include apply-gutter(\"margin-top\", $multiplier);\n}\n\n@mixin margin-right-gutter($multiplier: 1) {\n    @include apply-gutter(\"margin-right\", $multiplier);\n}\n\n@mixin margin-bottom-gutter($multiplier: 1) {\n    @include apply-gutter(\"margin-bottom\", $multiplier);\n}\n\n@mixin margin-left-gutter($multiplier: 1) {\n    @include apply-gutter(\"margin-left\", $multiplier);\n}\n\n@mixin gap-gutter($multiplier: 1) {\n    @include apply-gutter(\"gap\", $multiplier);\n}\n","@media (max-width: 575.98px) {\n  .blog-post > p:first-child {\n    margin-top: calc(1 * var(--gutter-x-small));\n  }\n}\n@media (min-width: 576px) and (max-width: 767.98px) {\n  .blog-post > p:first-child {\n    margin-top: calc(1 * var(--gutter-small));\n  }\n}\n@media (min-width: 768px) and (max-width: 991.98px) {\n  .blog-post > p:first-child {\n    margin-top: calc(1 * var(--gutter-medium));\n  }\n}\n@media (min-width: 992px) and (max-width: 1199.98px) {\n  .blog-post > p:first-child {\n    margin-top: calc(1 * var(--gutter-large));\n  }\n}\n@media (min-width: 1200px) {\n  .blog-post > p:first-child {\n    margin-top: calc(1 * var(--gutter-x-large));\n  }\n}\n.blog-post .field-type-taxonomyfield {\n  display: flex;\n  flex-direction: row;\n}\n.blog-post .taxonomy-tag-term, .blog-post .taxonomy-term {\n  font-style: italic;\n}\n.blog-post .field-type-taxonomyfield .taxonomy-tag-term::before {\n  content: \"|\";\n  padding: 0 0.5rem;\n}\n.blog-post .field-type-taxonomyfield .taxonomy-tag-term:first-child::before {\n  display: none;\n}\n@media (max-width: 575.98px) {\n  .blog-post .field-name-blog-post-image {\n    margin-bottom: calc(1 * var(--gutter-x-small));\n  }\n}\n@media (min-width: 576px) and (max-width: 767.98px) {\n  .blog-post .field-name-blog-post-image {\n    margin-bottom: calc(1 * var(--gutter-small));\n  }\n}\n@media (min-width: 768px) and (max-width: 991.98px) {\n  .blog-post .field-name-blog-post-image {\n    margin-bottom: calc(1 * var(--gutter-medium));\n  }\n}\n@media (min-width: 992px) and (max-width: 1199.98px) {\n  .blog-post .field-name-blog-post-image {\n    margin-bottom: calc(1 * var(--gutter-large));\n  }\n}\n@media (min-width: 1200px) {\n  .blog-post .field-name-blog-post-image {\n    margin-bottom: calc(1 * var(--gutter-x-large));\n  }\n}\n.blog-post .field-name-blog-post-image img {\n  height: var(--height-header);\n  width: 100%;\n  object-fit: cover;\n}\n.blog-post .field-name-blog-post-image .name {\n  display: none;\n}","// ---------------------------------------------------------------------------------------------------------------------\n// Application-wide Sass mixins\n// ---------------------------------------------------------------------------------------------------------------------\n\n// You can reference \"Assets/Styles/abstracts/_variables.scss\" here once and then you never have to again. Other .scss\n// files can import this one to have everything. Make sure to import \"variables\" before the Base Theme's \"mixins\",\n// because that imports some default Sass variable declarations and you want them to override your custom values.\n@import \"variables\";\n\n// Note for Visual Studio users: Sass resolves the @import \"../Lombiq.BaseTheme/Assets/Styles/abstracts/mixins\"; below,\n// but VS does not. Looks like Sass supports path lookup where the path root (sometimes referred to as \".\") is the\n// working directory (so the project directory where the package.json file is), while VS only supports paths relative to\n// the current scss file's location. If you have trouble with it, you can replace the below line with\n// @import \"../../../../Lombiq.BaseTheme/Assets/Styles/abstracts/mixins\"; which both support. VS doesn't support paths\n// starting with \"~\" either (https://developercommunity.visualstudio.com/t/Intellisense-not-working-in-sassscss-fi/33481)\n// and you can't use IntelliSense to resolve paths outside of your current project directory using either format.\n@import \"../Lombiq.BaseTheme/Assets/Styles/abstracts/mixins\";\n\n// In this case we create a mixin that crops a media field into a nice wide banner. It's applied both for sites and blog\n// posts in other files.\n@mixin media-field-banner {\n    // The \"mixins\" file in the Lombiq.BaseTheme has several utility mixins, including many \"gutter\" functions that help\n    // with applying uniform spacing between controls on your web site. Unless you have a specific reason not to, we\n    // suggest always using these to set gap (for grid and flexbox), margin and padding.\n    @include margin-bottom-gutter($multiplier: 1);\n\n    img {\n        height: var(--height-header);\n        width: 100%;\n        object-fit: cover;\n    }\n\n    .name { display: none; }\n}\n\n// NEXT STATION: Assets/Styles/general/_navigation.scss\n"]}